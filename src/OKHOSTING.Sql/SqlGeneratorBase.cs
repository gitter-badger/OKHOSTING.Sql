using OKHOSTING.Core.Data;
using OKHOSTING.Sql.Filters;
using OKHOSTING.Sql.Operations;
using OKHOSTING.Sql.Schema;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Linq;

namespace OKHOSTING.Sql
{
	/// <summary>
	/// Generates ANSI Sql script commands for DML and DDL
	/// </summary>
	public abstract class SqlGeneratorBase
	{
		/// <summary>
		/// Constructs the generator
		/// </summary>
		public SqlGeneratorBase() 
		{
		}

		#region Properties

		/// <summary>
		/// Represents the secuence of characters used to separate SQL scripts
		/// </summary>
		protected virtual string ScriptSeparator
		{
			get
			{
				return ";";
			}
		}

		/// <summary>
		/// Represent the opening character for enclosing table and column names
		/// </summary>
		/// <example>'[Name] (SQL Server), `Name` (MySQL), "Name" (Access)</example>
		protected virtual string NameEncloser_Begin
		{
			get
			{
				return "\"";
			}
		}

		/// <summary>
		/// Represent the closing character for enclosing table and column names
		/// </summary>
		/// <example>'[Name] (SQL Server), `Name` (MySQL), "Name" (Access)</example>
		protected virtual string NameEncloser_End
		{
			get
			{
				return "\"";
			}
		}

		/// <summary>
		/// Defines the name of the attribute used to generate autoincremental 
		/// fields (a null or string.Empty value defines that the Auto 
		/// Incremental Setting is not supported)
		/// </summary>
		protected abstract string AutoIncrementalSettingName
		{
			get;
		}

		/// <summary>
		/// Keyword for NULL values in the current SQL format
		/// </summary>
		protected virtual string Null
		{
			get
			{
				return "NULL";
			}
		}

		#endregion

		#region Insert

		/// <summary>
		/// Creates a Insert Sentence for the specified Table with 
		/// the values of the object indicated
		/// </summary>
		/// <param name="table">
		/// Table for Insert sentence create
		/// </param>
		/// <param name="dobj">
		/// object instance with the values to use in the Insert sentence
		/// </param>
		/// <returns>
		/// Insert Sql Sentence 
		/// </returns>
		public virtual Command Insert(Insert insert)
		{
			//Validating if table or dobj arguments are null
			if (insert == null) throw new ArgumentNullException("insert");

			string columnsList = string.Empty, valuesList = string.Empty;
			Command command = new Command();

			foreach (ColumnValue cv in insert.Values)
			{
				Int64 intValue = Int64.MinValue;

				if (cv.Column.IsNumeric)
				{
					try
					{
						intValue = (Int64)Convert.ChangeType(cv.Value, typeof(Int64));
					}
					catch { }
				}

				//if this is an autoincrement primary key and the value is null, ignore this field so its autogenerated
				if
				(
					cv.Column.IsAutoNumber &&
					cv.Column.IsPrimaryKey &&
					(cv.Value == null || intValue == 0)
				)
				{
					//ignore
					continue;
				}
				//otherwise, treat normally
				else
				{
					CommandParameter param = CreateCommandParameter(cv);

					columnsList += EncloseName(cv.Column.Name) + ", ";
					valuesList += param.Name + ", ";
					command.Parameters.Add(param);
				}
			}

			//Removing last ", "
			columnsList = columnsList.Remove(columnsList.Length - 2, 2);
			valuesList = valuesList.Remove(valuesList.Length - 2, 2);

			//Creating Insert Sentence and return it
			command.Script =
				"INSERT INTO " + EncloseName(insert.Into.Name) + " " +
				EncloseOnParenthesis(columnsList) +
				" VALUES " +
				EncloseOnParenthesis(valuesList);

			return command;
		}

		/// <summary>
		/// Returns a query for returning the auto-generated id of the last insert operation on a Table
		/// </summary>
		/// <param name="table">Table which table will be scanned for the last autogenerated primary key</param>
		/// <returns>Sql script that returns a single value containing the last auto generated primary key on a table</returns>
		public virtual Command LastAutogeneratedId(Table table)
		{
			return "SELECT " + AutoIncrementalFunction(table) + " AS ID";
		}

		/// <summary>
		/// Returns the name of the function used to retrieve the latest
		/// auto-generated primary key on the session
		/// </summary>
		/// <param name="table">Table which table will be scanned for the last autogenerated primary key</param>
		/// <returns>Sql function that returns a single value containing the last auto generated primary key on a table</returns>
		protected abstract Command AutoIncrementalFunction(Table table);

		#endregion

		#region Update

		/// <summary>
		/// Creates a UPDATE query for a single dataobject's Table
		/// </summary>
		/// <param name="table">
		/// Table considered in the Update
		/// </param>
		/// <param name="dobj">
		/// object instance for perform the update
		/// </param>
		/// <returns>
		/// Sql string for update the specified object
		/// </returns>
		public virtual Command Update(Update update)
		{
			//Validating if table argument is null
			if (update == null)
			{
				throw new ArgumentNullException("update");
			}

			//Creating Update sentence begin
			Command command = "UPDATE " + EncloseName(update.From.Name) + " SET ";

			//Crossing DataValues that aren't primary key
			foreach (var value in update.Set)
			{
				CommandParameter param = new CommandParameter(value.Value, "@" + value.Column.Name, value.Column.DbType);
				command.Parameters.Add(param);

				//Building the sql sentence...
				command.Script += 
					EncloseName(value.Column.Name) + 
					" = " + param.Name +
					", ";

			}

			//Remove the ", " if there is at least one updated property
			command.Script = command.Script.TrimEnd(',', ' ');

			//filters
			command += WhereClause(update.Where);

			//Returning the sentence
			return command;
		}

		#endregion

		#region Delete

		/// <summary>
		/// Get the Sql sentences for delete the specified DataObject and
		/// all his aggregate objects
		/// </summary>
		/// <param name="dobj">
		/// DataObject to Delete
		/// </param>
		/// <returns>
		/// Sql sentences for delete the specified DataObject and
		/// all his aggregate objects
		/// </returns>
		public virtual Command Delete(Delete delete)
		{
			//Validating if the specified DataObject is null
			if (delete == null)
			{
				throw new ArgumentNullException("delete");
			}

			Command command = "DELETE " + EncloseName(delete.From.Name);

			command += WhereClause(delete.Where);
		
			//Retrieving sql sentences for delete
			return command;
		}

		#endregion

		#region Select

		/// <summary>
		/// Returns the Sql sentence for select all the object's 
		/// of the specified Table, applying a filter collection
		/// </summary>
		/// <param name="table">
		/// Table that you desire to select
		/// </param>
		/// <param name="filters">
		/// Collection with the filters to apply on the query
		/// </param>
		/// <param name="orderName">
		/// Name of the order definition used to sort results,
		/// or null if not used
		/// </param>
		/// <returns>
		/// Sql sentence for select all the object's of the 
		/// specified Table, applying a filter collection
		/// </returns>
		public virtual Command Select(Select select)
		{
			//Validating if the table argument is null
			if (select == null) throw new ArgumentNullException("select");

			//Creating Select sentence
			Command command = SelectClause(select);
			command.Append(FromClause(select));
			command.Append(WhereClause(select.Where, LogicalOperator.And));
			command.Append(LimitClause(select.Limit));
			command.Append(OrderByClause(select.OrderBy));

			//Returning the sql sentence
			return command;
		}

		/// <summary>
		/// Returns a Select with aggregate functions
		/// </summary>
		/// <param name="aggegateSelectFields">
		/// Aggregate fields definitions
		/// </param>
		/// <param name="table">
		/// Table to query
		/// </param>
		/// <param name="filters">
		/// Filters to apply on Select
		/// </param>
		/// <param name="columnsToGroup">
		/// Columns for group by
		/// </param>
		/// <returns>
		/// Select Sentence with aggregate functions
		/// </returns>
		public virtual Command Select(SelectAggregate select)
		{
			//Validating arguments
			if (select == null) throw new ArgumentNullException("select");

			//Building the select sentence
			Command command = "SELECT ";

			//Crossing the fields definitions
			for (int counter = 0; counter < select.AggregateColumns.Count(); counter++)
			{
				command.Script += SelectAggregateColumn(select.AggregateColumns.ToList()[counter]) + ", ";
			}

			//Removing the last commas
			command.Script = command.Script.TrimEnd(',', ' ') + " ";

			//Adding From Clause
			command.Append(FromClause(select));

			//Adding Where Clause
			command.Append(WhereClause(select.Where, LogicalOperator.And));


			//Adding Group by Clause
			command.Append(GroupByClause(select.GroupBy));

			//adding the Order By clause, if exists
			command.Append(OrderByClause(select.OrderBy));

			//Returning the result
			return command;
		}


		/// <summary>
		/// Creates the Select Clause of a Select Sql Sentence
		/// </summary>
		/// <param name="table">
		/// Table for Select Clause creation
		/// </param>
		/// <returns>
		/// Select Clause from the Select Sql Sentence
		/// </returns>
		protected virtual Command SelectClause(Select select)
		{
			//Validating if table argument is null
			if (select == null) throw new ArgumentNullException("select");
			
			//use all columns if none is defined
			if (select.Columns.Count == 0)
			{
				foreach (Column c in select.From.Columns)
				{
					select.Columns.Add(c);
				}
			}

			//Creating Sql Clause
			string sql = "SELECT ";

			//Getting the Table DB table name
			string tableName = EncloseName(select.From.Name);

			//Crossing all the loaded members
			foreach (var c in select.Columns)
			{
				sql += string.Format("{0}.{1}", EncloseName(c.Column.Table.Name), EncloseName(c.Column.Name));
				
				if (!string.IsNullOrWhiteSpace(c.Alias))
				{
					sql += string.Format(" AS {0}", c.Alias);
				}

				sql += ", ";
			}

			//adding join columns
			foreach (var join in select.Joins)
			{
				foreach (var joinColumn in join.Columns)
				{
					string joinTableAlias = string.IsNullOrWhiteSpace(join.Alias) ? join.Table.Name : join.Alias;
					sql += string.Format("{0}.{1}", EncloseName(joinTableAlias), EncloseName(joinColumn.Column.Name));

					if (!string.IsNullOrWhiteSpace(joinColumn.Alias))
					{
						sql += string.Format(" AS {0}", joinColumn.Alias);
					}

					sql += ", ";
				}
			}

			//Removing last ", "
			sql = sql.TrimEnd(',', ' ');

			//Returning the Sql Sentence
			return sql;
		}

		/// <summary>
		/// Creates the Group By Clause for the Select Sentence
		/// </summary>
		/// <param name="dataValuesToGroup">
		/// Columns for group by
		/// </param>
		/// <returns>
		/// Group By Clause for the Select Sentence
		/// </returns>
		protected virtual Command GroupByClause(List<Column> dataValuesToGroup)
		{
			//Local Vars
			string groupByClause = string.Empty;

			//Validating if the columns for group are defined
			if (dataValuesToGroup == null || dataValuesToGroup.Count() == 0) return null;
			
			//Crossing the columns for group
			for (int counter = 0; counter < dataValuesToGroup.Count(); counter++)
			{
				groupByClause += EncloseName(dataValuesToGroup.ToList()[counter].Name) + ", ";
			}

			//Removing the last comma
			groupByClause = groupByClause.TrimEnd(',', ' ');

			//Returning the group by
			return groupByClause;
		}

		/// <summary>
		/// Creates the clause order by corresponding to the 
		/// Order definition specified
		/// </summary>
		/// <param name="table">
		/// Table that you desire to select
		/// </param>
		/// <param name="orderBy">
		/// List of OrderByItem, which are columns and sort directions
		/// </param>
		/// <returns>
		/// Clause order by corresponding to the 
		/// Order definition specified
		/// </returns>
		protected virtual Command OrderByClause(List<OrderBy> orderBy)
		{
			//local variables
			string orderString = "ORDER BY ";

			//Validating arguments
			if (orderBy == null || orderBy.Count() == 0) return null;

			//Building the final order definition
			foreach (var ob in orderBy)
			{
				orderString +=
					EncloseName(ob.Column.Name) +
					" " +
					Format(ob.Direction) +
					", ";
			}

			//Returning the order by
			return orderString.TrimEnd(',', ' ');
		}

		#endregion

		#region Filters

		protected virtual Command Filter(FilterBase filter)
		{
			//Validating if there are filters defined
			if (filter == null) return null;

			if (filter is ColumnCompareFilter) return Filter((ColumnCompareFilter)filter);
			if (filter is CustomFilter) return Filter((CustomFilter)filter);
			if (filter is InFilter) return Filter((InFilter)filter);
			if (filter is LikeFilter) return Filter((LikeFilter)filter);
			if (filter is RangeFilter) return Filter((RangeFilter)filter);
			if (filter is ValueCompareFilter) return Filter((ValueCompareFilter)filter);
			if (filter is LogicalOperatorFilter) return Filter((LogicalOperatorFilter)filter);

			throw new ArgumentOutOfRangeException("filter");
		}


		protected virtual Command Filter(ColumnCompareFilter filter)
		{
			//Validating if there are filters defined
			if (filter == null) return null;

			return
				EqualityComparison(
					ColumnFullName(filter),
					EncloseName(string.IsNullOrWhiteSpace(filter.ColumnToCompareTableAlias) ? filter.ColumnToCompare.Table.Name : filter.ColumnToCompareTableAlias) + "." + EncloseName(filter.ColumnToCompare.Name),
					filter.Operator
				);
		}

		protected virtual Command Filter(CustomFilter filter)
		{
			//Validating if there are filters defined
			if (filter == null) return null;

			return filter.Filter;
		}

		protected virtual Command Filter(InFilter filter)
		{
			//Validating if there are filters defined
			if (filter == null) return null;

			Command command = new Command();

			command.Append(ColumnFullName(filter));
			command.Append(InClause(filter.Values.ToList()));

			return command;
		}

		protected virtual Command Filter(LikeFilter filter)
		{
			//Validating if there are filters defined
			if (filter == null) return null;

			Command command = new Command();
			CommandParameter param = new CommandParameter(filter.Pattern, null, filter.Column.DbType);
			command.Parameters.Add(param);

			command.Script =
				EqualityComparison(
				ColumnFullName(filter),
				param.Name,
				CompareOperator.Like);

			return command;
		}

		protected virtual Command Filter(LogicalOperatorFilter filter)
		{
			//Validating if there are filters defined
			if (filter == null) return null;

			return Filter(filter.InnerFilters, filter.LogicalOperator);
		}

		protected virtual Command Filter(RangeFilter filter)
		{
			//Validating if there are filters defined
			if (filter == null) return null;

			Command command = new Command();
			CommandParameter minParam = new CommandParameter(filter.MinValue, null, filter.Column.DbType);
			command.Parameters.Add(minParam);

			CommandParameter maxParam = new CommandParameter(filter.MaxValue, null, filter.Column.DbType);
			command.Parameters.Add(maxParam);

			command.Append
			(
				LogicalExpression
				(
					EqualityComparison
					(
						ColumnFullName(filter),
						minParam.Name,
						CompareOperator.GreaterThanEqual
					),
					EqualityComparison
					(
						ColumnFullName(filter),
						maxParam.Name,
						CompareOperator.LessThanEqual
					),
					LogicalOperator.And,
					false
				)
			);

			return command;
		}

		protected virtual Command Filter(ValueCompareFilter filter)
		{
			//Validating if there are filters defined
			if (filter == null) return null;

			Command command = new Command();
			CommandParameter param = new CommandParameter(filter.ValueToCompare, null, filter.Column.DbType);
			command.Parameters.Add(param);

			command.Script =
				EqualityComparison
				(
					ColumnFullName(filter),
					param.Name,
					filter.Operator
				);

			return command;
		}

		protected virtual Command Filter(List<FilterBase> filters, LogicalOperator logicalOperator)
		{
			//Local Vars
			Command command = new Command();

			//Validating if there are filters defined
			if (filters == null || filters.Count() == 0) return null;

			//Getting the logical operator for merge filters
			string logicalOpr = Operator(logicalOperator);

			//Crossing the filters
			foreach (FilterBase f in filters)
			{
				//Adding filter condition
				var c = Filter(f);

				command.Append(c);
				command.Script += Operator(logicalOperator);
			}

			//Removing last logic operator
			command.Script = command.Script.Remove(command.Script.Length - logicalOpr.Length, logicalOpr.Length);

			return command;
		}

		#endregion

		#region Where, From, Limit, On, In

		/// <summary>
		/// Creates the Where Clause for a Select, Update and Delete Sql Sentence
		/// </summary>
		/// <param name="filter">
		/// Filter to serialize
		/// </param>
		/// <returns>
		/// Where Clause for a Select, Update and Delete Sql Sentence
		/// </returns>
		protected virtual Command WhereClause(FilterBase filter)
		{
			//Validating if there are filters defined
			if (filter == null) return null;

			//Creating filter collection
			List<FilterBase> filters = new List<FilterBase>();
			filters.Add(filter);

			//Getting the Where clausule
			return WhereClause(filters, LogicalOperator.And);
		}

		/// <summary>
		/// Creates the Where Clause for a Select, Update and Delete Sql Sentence
		/// </summary>
		/// <param name="filters">
		/// Filters to serialize
		/// </param>
		/// <param name="logicalOperator">
		/// Logical operator that will be used to merge 
		/// the where conditions
		/// </param>
		/// <returns>
		/// Where Clause for a Select, Update and Delete Sql Sentence
		/// </returns>
		protected virtual Command WhereClause(List<FilterBase> filters)
		{
			return WhereClause(filters, LogicalOperator.And);
		}

		/// <summary>
		/// Creates the Where Clause for a Select, Update and Delete Sql Sentence
		/// </summary>
		/// <param name="filters">
		/// Filters to serialize
		/// </param>
		/// <param name="logicalOperator">
		/// Logical operator that will be used to merge 
		/// the where conditions
		/// </param>
		/// <returns>
		/// Where Clause for a Select, Update and Delete Sql Sentence
		/// </returns>
		protected virtual Command WhereClause(List<FilterBase> filters, LogicalOperator logicalOperator)
		{
			//Validating if there are filters defined
			if (filters == null || filters.Count() == 0) return null;

			//Adding where Clause
			Command command = " WHERE ";
			command.Append(Filter(filters, logicalOperator));

			return command;
		}

		protected virtual Command OnClause(List<FilterBase> filters, LogicalOperator logicalOperator)
		{
			//Validating if there are filters defined
			if (filters == null || filters.Count == 0) return null;

			//Adding ON clause
			Command command = " ON ";
			command.Append(Filter(filters, logicalOperator));

			return command;
		}

		/// <summary>
		/// Creates the From Clause for a Select Sql Sentence
		/// </summary>
		/// <param name="table">
		/// Table for From Clause creation
		/// </param>
		/// <returns>
		/// From Clause from the Select Sql Sentence
		/// </returns>
		protected virtual Command FromClause(Select select)
		{
			//Validating if table argument is null
			if (select == null) throw new ArgumentNullException("select");

			//Creating the From Clause
			Command command = " From " + EncloseName(select.From.Name);

			//Crossing the inheritance until reach the root Table
			foreach (SelectJoin join in select.Joins)
			{
				//Resolve Joins
				command.Script += " " + join.JoinType.ToString().ToUpper() + " JOIN " + EncloseName(join.Table.Name) + (string.IsNullOrWhiteSpace(join.Alias)? string.Empty : " " + join.Alias) + " ON ";
				command.Append(Filter(join.On, LogicalOperator.And));
			}

			//Returning the From sql Clause	
			return command;
		}

		/// <summary>
		/// Creates the Limit clause for a Select sql sentence, used for paging
		/// </summary>
		/// <param name="limit">
		/// Starting and finishing indexes that define the subgroup of DataObjects retrieved by the select operation
		/// </param>
		/// <returns>
		/// Limit clause for a Select sql sentence
		/// </returns>
		protected virtual Command LimitClause(SelectLimit limit)
		{
			//Validating arguments
			if (limit == null) return null;

			return "LIMIT " + limit.From + ", " + limit.To;
		}

		/// <summary>
		/// Creates a Sql In clause for filters
		/// </summary>
		/// <typeparam name="listType">
		/// Type of the items in the list of values
		/// </typeparam>
		/// <param name="valuesList">
		/// List of values for create the In sentence
		/// </param>
		/// <returns>
		/// Sql In clause for filters
		/// </returns>
		protected virtual Command InClause(List<IComparable> valuesList)
		{
			//Initializing In clause
			Command command = new Command();
			command.Script = " IN (";
			string randomPrefix = new Random().Next(0, 999999).ToString();

			//Crossing the elements of the list
			for (int i = 0; i < valuesList.Count; i++)
			{
				IComparable item = valuesList[i];
				string paramName = randomPrefix + "_" + i;

				command.Script += paramName + ", ";
				command.Parameters.Add(new CommandParameter() { Name = paramName, DbType = DataBase.Parse(item.GetType()), Value = item });
			}

			//Removing last ", "
			command.Script = command.Script.TrimEnd(',', ' ');

			//Closing the clause
			command.Script += ")";

			//Returning the filter
			return command;
		}

		#endregion

		#region Create and Drop

		/// <summary>
		/// Creates a Create Table sentence for a single dataobject's Table
		/// </summary>
		/// <param name="table">
		/// Table for Create Table sentence creation 
		/// </param>
		/// <returns>
		/// Create Table Sql Sentence 
		/// </returns>
		public virtual Command Create(Table table)
		{
			//Begin the Create Table Creation
			Command sql = "CREATE TABLE " + EncloseName(table.Name) + " (";
			
			//Add columns
			foreach (var m in table.Columns)
			{
				//Processing column definition 
				sql += CreateColumnClause(m) + ", ";
			}

			//Adding primary key
			sql += PrimaryKeyDefinition(table) + ", ";

			//Creating indexes
			//foreach (Index index in table.InnerType.GetCustomAttributes(typeof(Index), false))
			//{
			//    sql += GetIndexDefinition(table, index) + ", ";
			//}

			//Removing the last ", "
			sql.Script = sql.Script.TrimEnd(',', ' ');

			//Enclosing the create table 
			sql += ")";

			//Returning the sql Sentence
			return sql;
		}

		/// <summary>
		/// Creates a DROP TABLE sentence for a single dataobject's Table
		/// </summary>
		/// <param name="table">
		/// Table for create te Drop sentence
		/// </param>
		/// <returns>
		/// Sql DROP TABLE sentence
		/// </returns>
		public virtual Command Drop(Table table)
		{
			return "DROP TABLE " + EncloseName(table.Name);
		}

		/// <summary>
		/// Returns the DML for create the column corresponding 
		/// with the specified Column
		/// </summary>
		/// <param name="column">
		/// Column for DML column creation
		/// </param>
		/// <returns>
		/// DML for create the column corresponding 
		/// with the specified Column
		/// </returns>
		protected virtual Command CreateColumnClause(Column column)
		{
			//Append the column Name
			string columnDefinition = EncloseName(column.Name) + " ";

			//if this is a string value, format as a string
			if (column.IsString)
			{
				if (column.Length.HasValue && column.Length > 0)
				{
					columnDefinition += FormatStringType(column.Length.Value);
				}
				else
				{
					//unlimited lenght by default
					columnDefinition += FormatStringType(0);
				}
			}
			//otherwise, format normally
			else
			{
				columnDefinition += Format(column.DbType);
			}

			if (!column.IsNullable)
			{
				columnDefinition += " NOT " + Null;
			}
			else
			{
				columnDefinition += " " + Null;
			}

			//Append the AutoIncrement flag, only if column is not part of a foreign key
			if (column.IsAutoNumber)
			{
				columnDefinition += " " + AutoIncrementalSettingName;
			}

			//Returning the column definition 
			return columnDefinition;
		}

		#endregion

		#region Contrains, Primary Keys, Indexes and Foreign keys

		/// <summary>
		/// Returns the Sql sentence for creating an index in the specified Table. Can be used when creating a table or after creation, for adding an index
		/// </summary>
		/// <param name="index">Index that will be added</param>
		protected virtual Command IndexDefinition(Index index)
		{
			//local vars
			string sql = string.Empty;

			//Creating the sql 
			sql +=
				(index.Unique ? "UNIQUE " : string.Empty) +
				"INDEX " +
				EncloseName(index.Name) +
				"(";

			//add columns to sql
			foreach (Column column in index.Columns)
			{
				sql += EncloseName(column.Name) + ", ";
			}

			//Enclosing the field lists
			sql = sql.TrimEnd(',', ' ');
			sql += ")";

			return sql;
		}

		/// <summary>
		/// Returns the Sql sentence for adding an index in the specified Table
		/// </summary>
		/// <param name="index">Index that will be added</param>
		/// <returns>Sql query for adding the index</returns>
		public virtual Command Create(Index index)
		{
			return "ALTER TABLE " + EncloseName(index.Table.Name) + " ADD " + IndexDefinition(index);
		}

		/// <summary>
		/// Returns the Sql sentence for dropping an index in the specified Table
		/// </summary>
		/// <param name="index">Index that will be dropped</param>
		/// <returns>Sql query for dropping the index</returns>
		public virtual Command Drop(Index index)
		{
			return "ALTER TABLE " + EncloseName(index.Table.Name) + " DROP INDEX " + EncloseName(index.Name);
		}

		/// <summary>
		/// Creates a Sql sentence for creating a foreign key
		/// </summary>
		/// <param name="column">Column that represents a foreign key</param>
		/// <returns>Sql sentence for creating a foreign key in the database</returns>
		protected virtual Command ForeignKeyDefinition(ForeignKey foreigkKey)
		{
			//Validate if column is a foreign key
			if (foreigkKey == null) throw new ArgumentNullException("foreigkKey");

			//sql script that wil be generated
			string sql = "CONSTRAINT " + EncloseName(foreigkKey.Name) + " FOREIGN KEY (";

			//add local columns
			foreach (Tuple<Column, Column> columnTuple in foreigkKey.Columns)
			{
				sql += EncloseName(columnTuple.Item1.Name) + ", ";
			}

			//remove last comma and close parenthesis
			sql = sql.TrimEnd(',', ' ');
			sql += ") REFERENCES " + EncloseName(foreigkKey.RemoteTable.Name) + "(";

			//add list of local columns
			foreach (Tuple<Column, Column> columnTuple in foreigkKey.Columns)
			{
				sql += EncloseName(columnTuple.Item2.Name) + ", ";
			}
			
			//Removing the last ", "
			sql = sql.TrimEnd(',', ' ');
			sql += ")";

			//Returning the sentence
			return sql;
		}

		/// <summary>
		/// Returns the Sql sentence for adding a foreign key in the specified Table
		/// </summary>
		/// <param name="index">Doreign key that will be added</param>
		/// <returns>Sql query for adding the foreign key</returns>
		public virtual Command Create(ForeignKey foreigkKey)
		{
			return "ALTER TABLE " + EncloseName(foreigkKey.Table.Name) + " ADD " + ForeignKeyDefinition(foreigkKey);
		}

		/// <summary>
		/// Returns the Sql sentence for dropping a foreign key in the specified Table
		/// </summary>
		/// <param name="index">Foreign key that will be dropped</param>
		/// <returns>Sql query for dropping the foreign key</returns>
		public virtual Command Drop(ForeignKey foreigkKey)
		{
			return "ALTER TABLE " + EncloseName(foreigkKey.Table.Name) + " DROP FOREIGN KEY " + EncloseName(foreigkKey.Name);
		}

		/// <summary>
		/// Returns the DML for define the primary key 
		/// constraint of the specified Table
		/// </summary>
		/// <param name="table">
		/// Table for primary key creation
		/// </param>
		/// <returns>
		/// DML for define the primary key 
		/// constraint of the specified Table
		/// </returns>
		protected virtual Command PrimaryKeyDefinition(Table table)
		{
			//Local Vars
			string primaryKeyConstraint;

			//Begin the primary key definition
			primaryKeyConstraint = "CONSTRAINT " + EncloseName("PK_" + table.Name) + " PRIMARY KEY (";

			//Crossing the DataValues for the primary key
			foreach (Column pk in table.PrimaryKey)
			{
				primaryKeyConstraint += EncloseName(pk.Name) + ", ";
			}

			//Removing the last ", " and enclosing the primary key Clause
			primaryKeyConstraint = primaryKeyConstraint.Remove(primaryKeyConstraint.Length - 2, 2);
			primaryKeyConstraint += ")";

			//Retuning the DML
			return primaryKeyConstraint;
		}

		#endregion

		#region Support methods

		/// <summary>
		/// Converts a SortDirection value to it's database-specific string representantion, so it can be included in a SQL script
		/// </summary>
		/// <param name="value">
		/// Value to be converted to string
		/// </param>
		/// <returns>
		/// A database-specific string representation of value
		/// </returns>
		protected virtual string Format(SortDirection value)
		{
			if (value == SortDirection.Ascending)
				return "ASC";
			else
				return "DESC";
		}

		/// <summary>
		/// Converts a Type to it's database-specific string representantion, so it can be included in a SQL script for creating or modifying tables
		/// </summary>
		/// <param name="dbType">
		/// Type to be converted to string
		/// </param>
		/// <returns>
		/// A database-specific string representation of the table
		/// </returns>
		/// <example>
		/// For typeof(Int32), "INTEGER" is returned
		/// </example>
		protected virtual string Format(DbType type)
		{
			//Getting the table name in Database
			switch (type)
			{
				case DbType.Binary:
				case DbType.Object:
					return "BINARY";

				case DbType.VarNumeric:
					return "BIGINT";

				case DbType.Currency:
					return "DECIMAL(10,2)";

				case DbType.Byte:
				case DbType.SByte:
					return "SMALLINT";

				case DbType.UInt16:
				case DbType.UInt32:
				case DbType.UInt64:
					return "INTEGER";

				case DbType.Int16:
				case DbType.Int32:
				case DbType.Int64:
					return "INTEGER";

				case DbType.Decimal:
					return "DECIMAL";

				case DbType.Single:
					return "FLOAT";

				case DbType.Double:
					return "REAL";

				case DbType.Boolean:
					return "BOOLEAN";

				case DbType.AnsiStringFixedLength:
				case DbType.StringFixedLength:
				case DbType.String:
					return "CHAR";

				case DbType.AnsiString:
				case DbType.Guid:
				case DbType.Xml:
					return "VARCHAR";

				case DbType.DateTime:
				case DbType.DateTime2:
				case DbType.DateTimeOffset:
					return "DATETIME";

				case DbType.Date:
					return "DATE";

				case DbType.Time:
					return "TIME";

			}

			//If the flow reaches the next line, the table is not 
			//recognized and then throw an exception
			throw new NotImplementedException("AnsiFormatProvider deoes not support type '" + type + "'");
		}

		/// <summary>
		/// Formats a string table depending of the lenght of the string table
		/// </summary>
		/// <param name="lenght">
		/// Lenght of the string table
		/// </param>
		/// <returns>
		/// A string representation af the text data table
		/// </returns>
		/// <example>
		/// if lenght is cero, "TEXT" is returned, is lengh is 20, CHAR(20) is returned
		/// </example>
		protected virtual string FormatStringType(int lenght)
		{
			//Validating the lenght of the string 
			if (lenght == 0)
				return "TEXT";
			else
				return Format(DbType.String) + " (" + lenght + ")";
		}

		/// <summary>
		/// Encloses a table or column name with NameEncloser_Begin and NameEncloser_End
		/// </summary>
		protected virtual string EncloseName(string name)
		{
			return
				NameEncloser_Begin +
				name +
				NameEncloser_End;
		}

		/// <summary>
		/// Returns the sql text of the aggregate field 
		/// </summary>
		/// <param name="selectAggregateColumn">
		/// Aggregate field definition
		/// </param>
		/// <returns>
		/// Sql text of the aggregate field 
		/// </returns>
		protected virtual string SelectAggregateColumn(SelectAggregateColumn selectAggregateColumn)
		{
			//Local vars
			List<string> aggregateFunctions = new List<string> { "AVG(", "COUNT(", "MIN(", "MAX(", "SUM(", string.Empty };

			//Defining the aggregate function
			string fieldText = aggregateFunctions[(int) selectAggregateColumn.AggregateFunction];

			//Defining the DISTINCT modifier
			fieldText +=
				(selectAggregateColumn.AggregateFunction != SelectAggregateFunction.None && selectAggregateColumn.Distinct ?
				"DISTINCT " : string.Empty);

			fieldText += ColumnFullName(selectAggregateColumn.Column);

			//Closing the parenthesis of aggregate function
			fieldText += (selectAggregateColumn.AggregateFunction != SelectAggregateFunction.None ? ")" : string.Empty);

			//Adding alias 
			fieldText +=
				(selectAggregateColumn.Alias != null && selectAggregateColumn.Alias.Trim() != string.Empty ?
				" as " + selectAggregateColumn.Alias :
				string.Empty);

			//Returning the aggregate field
			return fieldText;
		}

		/// <summary>
		/// Returns a string with the text of the specified logical operator
		/// </summary>
		/// <param name="logicalOperator">
		/// Logical operator that you desires
		/// </param>
		/// <returns>
		/// String with the text of the specified logical operator
		/// </returns>
		protected virtual string Operator(LogicalOperator logicalOperator)
		{
			return (logicalOperator == LogicalOperator.And ? " AND " : " OR ");
		}

		/// <summary>
		/// Create and returns a logical expression with the specified CommandParameters
		/// </summary>
		/// <param name="expressionLeft">
		/// Expression to the left of logical operator
		/// </param>
		/// <param name="expressionRight">
		/// Expression to the right of logical operator
		/// </param>
		/// <param name="logicalOperator">
		/// Logical operator 
		/// </param>
		/// <param name="encloseOnParenthesis">
		/// Indicates if the expression must be enclosed on parenthesis
		/// </param>
		/// <returns>
		/// Logical expression with the specified CommandParameters
		/// </returns>
		protected virtual string LogicalExpression(string expressionLeft, string expressionRight, LogicalOperator logicalOperator, bool encloseOnParenthesis)
		{
			//Getting the logical operator text
			string logicalOpr = Operator(logicalOperator);

			//Creating the logical expression
			string expression = expressionLeft + logicalOpr + expressionRight;

			//Returning the expression
			if (encloseOnParenthesis)
			{
				return EncloseOnParenthesis(expression);
			}
			else
			{
				return expression;
			}
		}

		/// <summary>
		/// Enclose the specified expression between parenthesis
		/// </summary>
		/// <param name="expression">
		/// Expression to enclose
		/// </param>
		/// <returns>
		/// The specified expression between parenthesis
		/// </returns>
		protected virtual string EncloseOnParenthesis(string expression)
		{
			return "(" + expression.Trim() + ")";
		}

		/// <summary>
		/// Returns a equality comparison sql expression
		/// </summary>
		/// <param name="comparisonLeft">
		/// Text to the left of the operator
		/// </param>
		/// <param name="comparisonRight">
		/// Text to the right of the operator
		/// </param>
		/// <param name="equalityOperator">
		/// Equality Operator that you desire to use
		/// </param>
		/// <returns>
		/// Equality comparison sql expression
		/// </returns>
		protected virtual string EqualityComparison(string comparisonLeft, string comparisonRight, CompareOperator equalityOperator)
		{
			//Local Vars
			List<string> operators = new List<string> { "=", "<>", ">", ">=", "<", "<=", "LIKE" };

			//Getting the applicable operator
			string applicableOperator = operators[(int) equalityOperator];

			//If value is NULL and operator is EQUAL, change to "is"
			if (string.IsNullOrWhiteSpace(comparisonRight) && equalityOperator == CompareOperator.Equal) applicableOperator = "IS";

			//If value is NULL and operator is NOT EQUAL, change to "is not"
			if (string.IsNullOrWhiteSpace(comparisonRight) && equalityOperator == CompareOperator.NotEqual) applicableOperator = "IS NOT";

			//Creating the expression and retrieving to the caller
			return comparisonLeft + " " + applicableOperator + " " + comparisonRight;
		}

		/// <summary>
		/// Returns the name of the specified field completly qualified
		/// </summary>
		/// <param name="column">
		/// Column to format
		/// </param>
		/// <returns>
		/// Name of the specified field completly qualified
		/// </returns>
		protected virtual string ColumnFullName(Column column)
		{
			return EncloseName(column.Table.Name) + "." + EncloseName(column.Name);
		}

		/// <summary>
		/// Returns the name of the specified field completly qualified
		/// </summary>
		/// <param name="column">
		/// Column to format
		/// </param>
		/// <returns>
		/// Name of the specified field completly qualified
		/// </returns>
		protected virtual string ColumnFullName(ColumnFilter filter)
		{
			return EncloseName(string.IsNullOrWhiteSpace(filter.TableAlias) ? filter.Column.Table.Name : filter.TableAlias) + "." + EncloseName(filter.Column.Name);
		}

		private static readonly Random Random = new Random();

		protected CommandParameter CreateCommandParameter(ColumnValue cv)
		{
			return CreateCommandParameter(cv.Value, cv.Column.DbType, ParameterDirection.Input, "@" + cv.Column.Name + Random.Next().ToString());
		}

		protected CommandParameter CreateCommandParameter(object value)
		{
			return CreateCommandParameter(value, DataBase.Parse(value.GetType()));
		}

		protected CommandParameter CreateCommandParameter(object value, DbType dbType)
		{
			return CreateCommandParameter(value, dbType, ParameterDirection.Input);
		}

		protected CommandParameter CreateCommandParameter(object value, DbType dbType, ParameterDirection direction)
		{
			return CreateCommandParameter(value, dbType, direction, null);
		}

		protected CommandParameter CreateCommandParameter(object value, DbType dbType, ParameterDirection direction, string name)
		{
			CommandParameter param = new CommandParameter();
			param.Value = value;
			param.DbType = dbType;
			param.Direction = direction;

			if (string.IsNullOrWhiteSpace(name))
			{
				param.Name = "@" + dbType + Random.Next().ToString();
			}
			else
			{
				param.Name = name;
			}

			return param;
		}

		#endregion
	}
}